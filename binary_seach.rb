# 二分探索
# 
# 典型問題
# - ソート済み配列での検索（存在判定/位置）
# - 「X以上が成り立つ最小のx」を求める境界探索（最小時間、最小コスト、最大長など）
# 
# 基本の考え方
# - 単調性（信義が一方向にしか変わらない特性）があるとき、探索範囲を半分に切り分けて目的の境界（条件を満たす最初の値）を見つける
# - 値が増えるほどOKになる / 条件を満たしやすくなる なら、最左OKや最右OK を狙える

# 問題
# N桁の数列Aの中で、値X以上の値のインデックスを返してください。
# 
# input:
# 5 16
# 1 5 10 15 20
# 
# output:
# 4

# 方針: l, rのポイントを内側に移動し、目的の値を見つけるまで繰り返す
# 計算量: 全探索ではO(n)だが、二分探索ではO(log n)
n, x = gets.chomp.split(' ').map(&:to_i)
a = gets.chomp.split(' ').map(&:to_i)

# [l, r) で最左OKを探す
l = 0
r = n
while l < r
  mid = (l + r) / 2
  if a[mid] >= x
    # 目的の値以上場合、rをmidに戻す
    r = mid
  else
    # 目的の値より小さい場合、lを進める
    l = mid + 1
  end
end

puts (l < n) ? l : -1
